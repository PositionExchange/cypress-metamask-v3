LavaPack.loadBundle([[3,{"../../shared/constants/app":6023,"../../shared/constants/metametrics":6027,"../../shared/constants/time":6032,"../../shared/modules/mv3.utils":6040,"./first-time-state":39,"./lib/createStreamSink":49,"./lib/ens-ipfs/setup":56,"./lib/get-first-preferred-lang-code":58,"./lib/getObjStructure":59,"./lib/local-store":60,"./lib/migrator":63,"./lib/network-store":64,"./lib/notification-manager":65,"./lib/util":83,"./metamask-controller":84,"./migrations":157,"./platforms/extension":158,"@babel/runtime/helpers/defineProperty":194,"@babel/runtime/helpers/interopRequireDefault":200,"@metamask/obs-store":1203,"@sentry/browser":1344,_process:5261,"debounce-stream":2105,"end-of-stream":2193,"eth-rpc-errors":2298,"extension-port-stream":2437,loglevel:5029,pump:5360,"webextension-polyfill":5998},function(){with(this)return function(){"use strict";return function(e,t,n){(function(t){(function(){var n=e("@babel/runtime/helpers/interopRequireDefault"),r=n(e("@babel/runtime/helpers/defineProperty")),a=n(e("end-of-stream")),o=n(e("pump")),s=n(e("debounce-stream")),i=n(e("loglevel")),l=n(e("webextension-polyfill")),c=e("@metamask/obs-store"),u=n(e("extension-port-stream")),d=e("@sentry/browser"),p=e("eth-rpc-errors"),f=e("../../shared/constants/app"),E=e("../../shared/constants/time"),g=e("../../shared/constants/metametrics"),m=e("../../shared/modules/mv3.utils"),M=n(e("./migrations")),T=n(e("./lib/migrator")),O=n(e("./platforms/extension")),b=n(e("./lib/local-store")),w=n(e("./lib/network-store")),C=n(e("./lib/createStreamSink")),N=v(e("./lib/notification-manager")),_=v(e("./metamask-controller")),h=n(e("./first-time-state")),y=n(e("./lib/get-first-preferred-lang-code")),A=n(e("./lib/getObjStructure")),P=n(e("./lib/ens-ipfs/setup")),S=e("./lib/util");function I(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,n=new WeakMap;return(I=function(e){return e?n:t})(e)}function v(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var n=I(t);if(n&&n.has(e))return n.get(e);var r={},a=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in e)if("default"!==o&&Object.prototype.hasOwnProperty.call(e,o)){var s=a?Object.getOwnPropertyDescriptor(e,o):null;s&&(s.get||s.set)?Object.defineProperty(r,o,s):r[o]=e[o]}return r.default=e,n&&n.set(e,r),r}function R(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}const{sentry:L}=global,D=function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?R(Object(n),!0).forEach((function(t){(0,r.default)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):R(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}({},h.default),k={[f.ENVIRONMENT_TYPE_POPUP]:!0,[f.ENVIRONMENT_TYPE_NOTIFICATION]:!0,[f.ENVIRONMENT_TYPE_FULLSCREEN]:!0},x=["trezor-connect"];i.default.setDefaultLevel(t.env.METAMASK_DEBUG?"debug":"info");const j=new O.default,U=new N.default;global.METAMASK_NOTIFIER=U;let V=!1,B=!1,F=!1;const G={},K={},Y=t.env.IN_TEST,q=Y?new w.default:new b.default;let J;(Y||t.env.METAMASK_DEBUG)&&(global.metamaskGetState=q.get.bind(q));const z=new URL("https://metamask.github.io/phishing-warning/v1.1.0/"),W=async e=>{l.default.runtime.onConnect.removeListener(W),await $(e),i.default.info("MetaMask initialization complete.")};async function $(e){const t=await async function(){const e=new T.default({migrations:M.default});e.on("error",console.warn),J=await q.get()||e.generateInitialState(D),J&&!J.data&&(J=e.generateInitialState(D),L.captureMessage("MetaMask - Empty vault found - unable to recover"));if(e.on("error",(e=>{const t=(0,A.default)(J);L.captureException(e,{extra:{vaultStructure:t}})})),J=await e.migrateData(J),!J)throw new Error("MetaMask - migrator returned undefined");q.isSupported?q.set(J):setTimeout((()=>{throw new Error("MetaMask - Localstore not supported")}));return J.data}(),n=await(0,y.default)();await function(e,t,n){const r=new _.default({infuraProjectId:"9aa3d95b3bc440fa88ea12eaa4456161",showUserConfirmation:X,openPopup:Q,initState:e,initLangCode:t,platform:j,notificationManager:U,browser:l.default,getRequestAccountTabIds:()=>K,getOpenMetamaskTabsIds:()=>G});function E(e){return J.data=e,J}(0,P.default)({getCurrentChainId:r.networkController.getCurrentChainId.bind(r.networkController),getIpfsGateway:r.preferencesController.getIpfsGateway.bind(r.preferencesController),provider:r.provider}),(0,o.default)((0,c.storeAsStream)(r.store),(0,s.default)(1e3),(0,c.storeTransformStream)(E),(0,C.default)(T),(e=>{i.default.error("MetaMask - Persistence pipeline failed",e)}));let M=!1;async function T(e){if(!e)throw new Error("MetaMask - updated state is missing");if(!e.data)throw new Error("MetaMask - updated state does not have data");if(q.isSupported)try{await q.set(e),M&&(M=!1)}catch(e){M||(M=!0,(0,d.captureException)(e)),i.default.error("error setting state in local store:",e)}}(0,m.isManifestV3)()&&n&&w(n);l.default.runtime.onConnect.addListener(w),l.default.runtime.onConnectExternal.addListener(h);const O=()=>V||Boolean(Object.keys(G).length)||B,b=(e,t)=>{if(!1===e)r.onClientClosed();else{if(t===f.ENVIRONMENT_TYPE_FULLSCREEN&&Boolean(Object.keys(G).length))return;r.onEnvironmentTypeClosed(t)}};function w(e){var t;const n=e.name;if(x.includes(e.name))return;let o=!1;o=(0,S.getPlatform)()===f.PLATFORM_FIREFOX?k[n]:e.sender.origin===`chrome-extension://${l.default.runtime.id}`;const s=null!==(t=e.sender)&&void 0!==t&&t.url?new URL(e.sender.url):null;if(o){const t=new u.default(e);if(r.isClientOpen=!0,r.setupTrustedCommunication(t,e.sender),(0,m.isManifestV3)()&&e.postMessage({name:"CONNECTION_READY"}),n===f.ENVIRONMENT_TYPE_POPUP&&(V=!0,(0,a.default)(t,(()=>{V=!1;const e=O();r.isClientOpen=e,b(e,f.ENVIRONMENT_TYPE_POPUP)}))),n===f.ENVIRONMENT_TYPE_NOTIFICATION&&(B=!0,(0,a.default)(t,(()=>{B=!1;const e=O();r.isClientOpen=e,b(e,f.ENVIRONMENT_TYPE_NOTIFICATION)}))),n===f.ENVIRONMENT_TYPE_FULLSCREEN){const n=e.sender.tab.id;G[n]=!0,(0,a.default)(t,(()=>{delete G[n];const e=O();r.isClientOpen=e,b(e,f.ENVIRONMENT_TYPE_FULLSCREEN)}))}}else if(s&&s.origin===z.origin&&s.pathname===z.pathname){const t=new u.default(e);r.setupPhishingCommunication({connectionStream:t})}else{if(e.sender&&e.sender.tab&&e.sender.url){const t=e.sender.tab.id,n=new URL(e.sender.url),{origin:r}=n;e.onMessage.addListener((e=>{e.data&&"eth_requestAccounts"===e.data.method&&(K[r]=t)}))}h(e)}}function h(e){const t=new u.default(e);r.setupUntrustedCommunication({connectionStream:t,sender:e.sender})}function y(){let e="";const t=A();t&&(e=String(t)),(0,m.isManifestV3)()?(l.default.action.setBadgeText({text:e}),l.default.action.setBadgeBackgroundColor({color:"#037DD6"})):(l.default.browserAction.setBadgeText({text:e}),l.default.browserAction.setBadgeBackgroundColor({color:"#037DD6"}))}function A(){const e=r.txController.getUnapprovedTxCount(),{unapprovedMsgCount:t}=r.messageManager,{unapprovedPersonalMsgCount:n}=r.personalMessageManager,{unapprovedDecryptMsgCount:a}=r.decryptMessageManager,{unapprovedEncryptionPublicKeyMsgCount:o}=r.encryptionPublicKeyManager,{unapprovedTypedMessagesCount:s}=r.typedMessageManager;return e+t+n+a+o+s+r.approvalController.getTotalApprovalCount()+r.appStateController.waitingForUnlock.length}function I(){Object.keys(r.txController.txStateManager.getUnapprovedTxList()).forEach((e=>r.txController.txStateManager.setTxStatusRejected(e))),r.messageManager.messages.filter((e=>"unapproved"===e.status)).forEach((e=>r.messageManager.rejectMsg(e.id,g.REJECT_NOTFICIATION_CLOSE_SIG))),r.personalMessageManager.messages.filter((e=>"unapproved"===e.status)).forEach((e=>r.personalMessageManager.rejectMsg(e.id,g.REJECT_NOTFICIATION_CLOSE_SIG))),r.typedMessageManager.messages.filter((e=>"unapproved"===e.status)).forEach((e=>r.typedMessageManager.rejectMsg(e.id,g.REJECT_NOTFICIATION_CLOSE_SIG))),r.decryptMessageManager.messages.filter((e=>"unapproved"===e.status)).forEach((e=>r.decryptMessageManager.rejectMsg(e.id,g.REJECT_NOTFICIATION_CLOSE))),r.encryptionPublicKeyManager.messages.filter((e=>"unapproved"===e.status)).forEach((e=>r.encryptionPublicKeyManager.rejectMsg(e.id,g.REJECT_NOTFICIATION_CLOSE))),r.approvalController.clear(p.ethErrors.provider.userRejectedRequest()),y()}return y(),r.txController.on(_.METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE,y),r.messageManager.on(_.METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE,y),r.personalMessageManager.on(_.METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE,y),r.decryptMessageManager.on(_.METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE,y),r.encryptionPublicKeyManager.on(_.METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE,y),r.typedMessageManager.on(_.METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE,y),r.appStateController.on(_.METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE,y),r.controllerMessenger.subscribe(_.METAMASK_CONTROLLER_EVENTS.APPROVAL_STATE_CHANGE,y),U.on(N.NOTIFICATION_MANAGER_EVENTS.POPUP_CLOSED,(({automaticallyClosed:e})=>{e?A()>0&&X():I()})),Promise.resolve()}(t,n,e),await async function(){let e;try{const t=new URL("https://metamask.github.io/phishing-warning/v1.1.0/");let n,r;t.hash="#extensionStartup",e=window.document.createElement("iframe"),e.setAttribute("src",t.href),e.setAttribute("sandbox","allow-scripts allow-same-origin");const a=new Promise(((e,t)=>{n=e,r=t}));e.addEventListener("load",n),window.document.body.appendChild(e),setTimeout((()=>r(new H)),1e3),await a}catch(e){e instanceof H?console.warn("Phishing warning page timeout; page not guaraneteed to work offline."):console.error("Failed to initialize phishing warning page",e)}finally{e&&e.remove()}}(),i.default.info("MetaMask initialization complete.")}(0,m.isManifestV3)()?l.default.runtime.onConnect.addListener(W):$().catch(i.default.error);class H extends Error{constructor(){super("Timeout failed")}}async function X(){const e=await j.getActiveTabs(),t=Boolean(e.find((e=>G[e.id]))),n=e.length>0&&e[0].extData&&e[0].extData.indexOf("vivaldi_tab")>-1;if(!F&&(n||!V)&&!t){F=!0;try{await U.showPopup()}finally{F=!1}}}async function Q(){await X(),await new Promise((e=>{const t=setInterval((()=>{B||(clearInterval(t),e())}),E.SECOND)}))}l.default.runtime.onInstalled.addListener((({reason:e})=>{"install"!==e||t.env.METAMASK_DEBUG||t.env.IN_TEST||j.openExtensionInBrowser()}))}).call(this)}).call(this,e("_process"))}}},{package:"$root$"}]],[3],{});